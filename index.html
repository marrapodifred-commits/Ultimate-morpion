<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="theme-color" content="#0f172a">
<title>Ultimate Morpion</title>
<style>
  :root{
    --bg:#ffffff;
    --fg:#0f172a;
    --muted:#6b7280;
    --grid:#e5e7eb;
    --grid-strong:#cbd5e1;
    --x:#e53935;
    --o:#2563eb;
    --active:#f1f5f9;
    --accent:#111827;
    --accent-fg:#ffffff;
    --win:#10b981;
    --size:min(92vmin, 900px);
    --mini-gap:10px;
  }

  [data-theme="dark"] {
    --bg:#0f172a;
    --fg:#f1f5f9;
    --muted:#94a3b8;
    --grid:#334155;
    --grid-strong:#475569;
    --active:#1e293b;
    --accent:#f1f5f9;
    --accent-fg:#0f172a;
  }

  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;width:100%}
  body{
    background:var(--bg); 
    color:var(--fg);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    display:flex; 
    flex-direction:column; 
    align-items:center; 
    gap:14px; 
    padding:14px 10px 28px;
    overflow-x:hidden;
  }

  header, .bar { 
    width:100%;
    max-width:1200px;
  }

  header{ 
    display:flex; 
    flex-wrap:wrap; 
    align-items:center; 
    justify-content:space-between; 
    gap:12px; 
  }
  
  header h1{ 
    font-size:20px; 
    font-weight:800; 
  }

  .controls{ 
    display:flex; 
    flex-wrap:wrap; 
    gap:8px; 
    align-items:center; 
  }
  
  select, input, button{
    font:inherit; 
    border:1px solid var(--grid-strong); 
    border-radius:10px; 
    padding:8px 10px; 
    background:var(--bg); 
    color:var(--fg);
    cursor:pointer;
  }
  
  button{
    display:inline-flex;
    align-items:center;
    gap:6px;
    font-size:20px;
  }
  
  button.accent{ 
    background:var(--accent); 
    color:var(--accent-fg); 
    border:none; 
    font-weight:600; 
  }
  
  button:disabled{ 
    opacity:.6; 
    cursor:not-allowed; 
  }

  #themeToggle{
    padding:8px 12px;
    background:var(--accent);
    color:var(--accent-fg);
    border:none;
    border-radius:10px;
    font-size:20px;
  }

  .bar{
    display:flex; 
    align-items:center; 
    justify-content:space-between; 
    gap:10px; 
    flex-wrap:wrap;
    padding:8px 0;
    width:100%;
  }
  
  .status{
    padding:8px 12px; 
    border:1px dashed var(--grid-strong); 
    border-radius:10px; 
    background:var(--bg);
    display:flex; 
    align-items:center; 
    gap:10px; 
    min-height:40px;
  }
  
  .badge{ 
    padding:4px 8px; 
    border-radius:999px; 
    font-weight:700; 
    background:var(--active); 
    border:1px solid var(--grid-strong); 
  }
  
  .dot{ 
    width:10px; 
    height:10px; 
    border-radius:50%; 
    display:inline-block; 
    margin-right:6px; 
  }
  
  .dot.x{ background:var(--x); } 
  .dot.o{ background:var(--o); }
  .small{ color:var(--muted); font-size:12px }

  #chronoDisplay {
    font-size:20px;
    font-weight:600;
    padding:8px 16px;
    background:var(--active);
    border:2px solid var(--grid-strong);
    border-radius:12px;
    min-width:80px;
    text-align:center;
    color:var(--muted);
  }

  .board{
    width:var(--size); 
    height:var(--size);
    display:grid; 
    grid-template-columns:repeat(3,1fr); 
    grid-template-rows:repeat(3,1fr);
    gap:var(--mini-gap);
    margin:20px auto;
  }
  
  .mini{
    position:relative; 
    background:var(--bg); 
    border:3px solid var(--grid-strong); 
    border-radius:12px; 
    overflow:hidden;
    display:grid; 
    grid-template-columns:repeat(3,1fr); 
    grid-template-rows:repeat(3,1fr);
  }
  
  .mini.active{ 
    background:#f0fdf4; 
    border-color:#10b981; 
    box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2);
  }
  
  [data-theme="dark"] .mini.active {
    background:#064e3b;
  }

  .mini.won .cell {
    filter: grayscale(35%) brightness(0.92);
    opacity: 0.85;
  }

  .cell{
    position:relative; 
    border:1px solid var(--grid); 
    display:flex; 
    align-items:center; 
    justify-content:center; 
    cursor:pointer;
    background:var(--bg); 
    min-height:30px;
  }
  
  .cell:hover{ 
    background:var(--active); 
  }
  
  .cell.disabled{ 
    pointer-events:none; 
    background:var(--active); 
  }

  .cell .mark{ 
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 70%;
    height: 70%;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .cell .mark svg{ 
    width: 100%; 
    height: 100%; 
    stroke: currentColor; 
    fill: none;
    stroke-linecap: round;
    stroke-linejoin: round;
    stroke-width: 3;
  }
  
  .cell .mark.x{ color:var(--x); }
  .cell .mark.o{ color:var(--o); }

  .winnerOverlay{
    position:absolute; 
    inset:4px; 
    pointer-events:none; 
    z-index:5; 
    display:flex; 
    align-items:center; 
    justify-content:center;
  }
  
  .winnerOverlay svg{ 
    width:85%; 
    height:85%; 
    fill:none; 
    stroke-linecap:round; 
    stroke-linejoin:round; 
    stroke-width:5;
  }
  
  .mini.winX .winnerOverlay svg{ 
    stroke:var(--x); 
  }
  
  .mini.winO .winnerOverlay svg{ 
    stroke:var(--o); 
  }

  .hide{ display:none !important; }
  .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .grow{ flex:1; min-width:200px; }

  @media (max-width: 768px) {
    body {
      padding: 8px 5px 20px;
    }

    header h1 {
      font-size: 18px;
      width: 100%;
      text-align: center;
    }

    .controls {
      width: 100%;
      justify-content: center;
      font-size: 14px;
    }

    .board {
      --size: min(95vmin, 95vw);
      --mini-gap: 6px;
    }
  }
</style>
</head>
<body>

<header>
  <h1>üéÆ Ultimate Morpion</h1>
  <div class="controls">
    <button id="themeToggle" type="button">üåì</button>
    
    <label>Mode :
      <select id="modeSel">
        <option value="local">Local 2 joueurs</option>
        <option value="ai">VS IA</option>
      </select>
    </label>

    <span id="aiWrap" class="row hide">
      <label>Niveau IA :
        <select id="aiLevelSel">
          <option value="1">Niveau 1</option>
          <option value="2">Niveau 2</option>
          <option value="3" selected>Niveau 3</option>
          <option value="4">Niveau 4</option>
          <option value="5">Niveau 5</option>
        </select>
      </label>
    </span>

    <button id="resetBtn" type="button">üîÑ</button>
    <button id="undoBtn" type="button">‚Ü©Ô∏è</button>
  </div>
</header>

<div class="bar">
  <div id="status" class="status grow">
    <span class="badge"><span class="dot x"></span>Tour : X</span>
    <span id="activeMiniText" class="small">Mini impos√© : libre</span>
  </div>
  <div class="row">
    <span id="chronoDisplay">0:00</span>
  </div>
</div>

<div id="board" class="board"></div>

<script>
console.log('üéÆ D√©marrage du jeu...');

const LINES = [
  [0,1,2],[3,4,5],[6,7,8],
  [0,3,6],[1,4,7],[2,5,8],
  [0,4,8],[2,4,6]
];

const state = {
  board: Array.from({length:9},()=>Array(9).fill(null)),
  miniStatus: Array(9).fill(null),
  current: 'X',
  forcedMini: null,
  globalWin: null,
  history: [],
  mode: 'local',
  aiLevel: 3,
  chrono: null,
  chronoTime: 0,
  theme: 'light'
};

const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const activeMiniTextEl = document.getElementById('activeMiniText');
const modeSel = document.getElementById('modeSel');
const aiLevelSel = document.getElementById('aiLevelSel');
const aiWrap = document.getElementById('aiWrap');
const resetBtn = document.getElementById('resetBtn');
const undoBtn = document.getElementById('undoBtn');
const themeToggle = document.getElementById('themeToggle');
const chronoDisplay = document.getElementById('chronoDisplay');

console.log('üìã √âl√©ments charg√©s');

function loadTheme() {
  const saved = localStorage.getItem('theme') || 'light';
  state.theme = saved;
  document.documentElement.setAttribute('data-theme', saved);
  themeToggle.textContent = saved === 'dark' ? '‚òÄÔ∏è' : 'üåì';
}

themeToggle.addEventListener('click', () => {
  state.theme = state.theme === 'light' ? 'dark' : 'light';
  document.documentElement.setAttribute('data-theme', state.theme);
  localStorage.setItem('theme', state.theme);
  themeToggle.textContent = state.theme === 'dark' ? '‚òÄÔ∏è' : 'üåì';
});

function startChrono() {
  if (state.chrono) return;
  state.chronoTime = 0;
  updateChronoDisplay();
  state.chrono = setInterval(() => {
    state.chronoTime++;
    updateChronoDisplay();
  }, 1000);
}

function stopChrono() {
  if (state.chrono) {
    clearInterval(state.chrono);
    state.chrono = null;
  }
}

function updateChronoDisplay() {
  const minutes = Math.floor(state.chronoTime / 60);
  const seconds = state.chronoTime % 60;
  chronoDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

function cellMark(player){
  if (player==='X'){
    return `<span class="mark x"><svg viewBox="0 0 24 24"><path d="M5 5L19 19"></path><path d="M19 5L5 19"></path></svg></span>`;
  } else {
    return `<span class="mark o"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="8"></circle></svg></span>`;
  }
}

function bigOverlaySVG(player){
  if (player==='X'){
    return {
      colorClass:'winX',
      shape:`<svg viewBox="0 0 24 24"><path d="M5 5L19 19"></path><path d="M19 5L5 19"></path></svg>`
    };
  } else {
    return {
      colorClass:'winO',
      shape:`<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="8"></circle></svg>`
    };
  }
}

function fullRender(){
  console.log('üé® Cr√©ation du plateau...');
  boardEl.innerHTML = '';
  
  for (let m=0; m<9; m++){
    const miniEl = document.createElement('div');
    miniEl.className = 'mini';
    miniEl.dataset.mini = m;

    for (let c=0; c<9; c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.m = m;
      cell.dataset.c = c;
      cell.addEventListener('click', onCellClick);
      miniEl.appendChild(cell);
    }

    boardEl.appendChild(miniEl);
  }
  
  console.log('‚úÖ Plateau cr√©√© !');
  render();
}

function render(){
  for (let m=0; m<9; m++){
    const miniEl = boardEl.children[m];
    if (!miniEl) continue;
    
    const miniWon = state.miniStatus[m];
    const isActive = isMiniPlayable(m);
    miniEl.classList.toggle('active', isActive && !state.globalWin);

    for (let c=0; c<9; c++){
      const cell = miniEl.children[c];
      if (!cell) continue;
      
      const canPlay = !state.globalWin && isActive && !state.board[m][c];
      cell.classList.toggle('disabled', !canPlay);
      cell.innerHTML = '';
      
      if (state.board[m][c]){
        cell.innerHTML = cellMark(state.board[m][c]);
      }
    }

    miniEl.classList.remove('winX','winO','won');
    const prevOverlay = miniEl.querySelector('.winnerOverlay');
    if (prevOverlay) prevOverlay.remove();
    
    if (miniWon==='X' || miniWon==='O'){
      const { colorClass, shape } = bigOverlaySVG(miniWon);
      miniEl.classList.add(colorClass);
      miniEl.classList.add('won');
      
      const ov = document.createElement('div');
      ov.className = 'winnerOverlay';
      ov.innerHTML = shape;
      miniEl.appendChild(ov);
    }
  }

  const cur = state.current;
  const dot = `<span class="dot ${cur.toLowerCase()}"></span>`;
  
  if (!state.globalWin){
    statusEl.innerHTML = `<span class="badge">${dot}Tour : ${cur}</span>`;
  } else if (state.globalWin==='D'){
    statusEl.innerHTML = `<span class="badge">Match nul</span>`;
  } else {
    const winner = state.globalWin;
    const wdot = `<span class="dot ${winner.toLowerCase()}"></span>`;
    statusEl.innerHTML = `<span class="badge">${wdot}${winner} a gagn√© !</span>`;
  }

  if (state.forcedMini===null){
    activeMiniTextEl.textContent = 'Mini impos√© : libre';
  } else {
    activeMiniTextEl.textContent = `Mini impos√© : ${state.forcedMini+1}`;
  }
}

function isMiniPlayable(m){
  if (state.forcedMini!==null) return state.forcedMini===m;
  return !state.miniStatus[m];
}

function checkLine3(arr, player){
  return LINES.some(([a,b,c])=>arr[a]===player && arr[b]===player && arr[c]===player);
}

function miniWinner(m){
  const grid = state.board[m];
  if (checkLine3(grid,'X')) return 'X';
  if (checkLine3(grid,'O')) return 'O';
  if (grid.every(v=>v!==null)) return 'D';
  return null;
}

function isMiniFull(m){ 
  return state.board[m].every(v=>v!==null); 
}

function updateMiniAndGlobal(m){
  const win = miniWinner(m);
  if (win && !state.miniStatus[m]) state.miniStatus[m] = win;
  
  const macro = Array(9).fill(null).map((_,i)=>{
    return state.miniStatus[i]==='X' ? 'X' : state.miniStatus[i]==='O' ? 'O' : null;
  });
  
  if (checkLine3(macro,'X')) state.globalWin = 'X';
  else if (checkLine3(macro,'O')) state.globalWin = 'O';
  else if (state.miniStatus.every(s=>s)) state.globalWin = 'D';
  
  if (state.globalWin) {
    stopChrono();
    alert(state.globalWin === 'D' ? 'Match nul !' : `${state.globalWin} a gagn√© !`);
  }
}

function applyMove(m,c,fromPlayer=null){
  const player = fromPlayer || state.current;
  if (state.globalWin) return false;
  if (state.board[m][c]!==null) return false;
  if (!isMiniPlayable(m)) return false;

  state.board[m][c] = player;
  
  state.history.push({ 
    m, c, player, 
    prevForced: state.forcedMini, 
    prevMiniStatus: state.miniStatus.slice(), 
    prevGlobal: state.globalWin 
  });

  updateMiniAndGlobal(m);

  const targetMini = c;
  if (state.miniStatus[targetMini] || isMiniFull(targetMini)){
    state.forcedMini = null;
  } else {
    state.forcedMini = targetMini;
  }

  state.current = state.current==='X' ? 'O' : 'X';
  return true;
}

function resetGame(){
  stopChrono();
  state.board = Array.from({length:9},()=>Array(9).fill(null));
  state.miniStatus = Array(9).fill(null);
  state.current = 'X';
  state.forcedMini = null;
  state.globalWin = null;
  state.history = [];
  fullRender();
  startChrono();
}

function undo(){
  if (state.mode==='ai') return;
  if (state.history.length===0) return;
  const last = state.history.pop();
  state.board[last.m][last.c] = null;
  state.forcedMini = last.prevForced;
  state.miniStatus = last.prevMiniStatus;
  state.globalWin = last.prevGlobal;
  state.current = last.player;
  render();
}

function cloneState(){
  return {
    board: state.board.map(mini=>mini.slice()),
    miniStatus: state.miniStatus.slice(),
    current: state.current,
    forcedMini: state.forcedMini,
    globalWin: state.globalWin
  };
}

function restoreState(snap){
  state.board = snap.board;
  state.miniStatus = snap.miniStatus;
  state.current = snap.current;
  state.forcedMini = snap.forcedMini;
  state.globalWin = snap.globalWin;
}

function getPossibleMoves(){
  if (state.globalWin) return [];
  const moves = [];
  if (state.forcedMini!==null){
    const m = state.forcedMini;
    if (!state.miniStatus[m]){
      for (let c=0;c<9;c++){
        if (!state.board[m][c]) moves.push({m,c});
      }
    }
  } else {
    for (let m=0;m<9;m++){
      if (state.miniStatus[m]) continue;
      for (let c=0;c<9;c++){
        if (!state.board[m][c]) moves.push({m,c});
      }
    }
  }
  return moves;
}

function evaluate(){
  let score = 0;
  for (let m=0;m<9;m++){
    if (state.miniStatus[m]==='X') score+=3;
    else if (state.miniStatus[m]==='O') score-=3;
  }
  if (state.globalWin==='X') score+=999;
  else if (state.globalWin==='O') score-=999;
  return score;
}

function aiMove(){
  const depth = state.aiLevel;
  const moves = getPossibleMoves();
  if (moves.length===0) return null;
  
  let bestMove = null;
  let bestVal = -Infinity;

  for (const mv of moves){
    const snapshot = cloneState();
    applyMove(mv.m, mv.c, state.current);
    const val = minimax(depth-1, -Infinity, Infinity);
    restoreState(snapshot);
    if (val > bestVal){
      bestVal = val;
      bestMove = mv;
    }
  }
  return bestMove;
}

function minimax(depth, alpha, beta){
  if (depth===0 || state.globalWin) return evaluate();
  const moves = getPossibleMoves();
  if (moves.length===0) return evaluate();

  const me = state.current;
  if (me==='X'){
    let value = -Infinity;
    for (const mv of moves){
      const snapshot = cloneState();
      applyMove(mv.m, mv.c, me);
      value = Math.max(value, minimax(depth-1, alpha, beta));
      restoreState(snapshot);
      alpha = Math.max(alpha, value);
      if (beta<=alpha) break;
    }
    return value;
  } else {
    let value = Infinity;
    for (const mv of moves){
      const snapshot = cloneState();
      applyMove(mv.m, mv.c, me);
      value = Math.min(value, minimax(depth-1, alpha, beta));
      restoreState(snapshot);
      beta = Math.min(beta, value);
      if (beta<=alpha) break;
    }
    return value;
  }
}

function onCellClick(e){
  const m = +e.currentTarget.dataset.m;
  const c = +e.currentTarget.dataset.c;

  console.log(`Clic sur mini ${m}, case ${c}`);

  if (!applyMove(m,c)) return;

  render();
  
  if (state.mode === 'ai' && !state.globalWin && state.current === 'O') {
    setTimeout(()=>{
      const mv = aiMove();
      if (mv){
        applyMove(mv.m, mv.c);
        render();
      }
    }, 300);
  }
}

function updateUI(){
  aiWrap.classList.toggle('hide', state.mode!=='ai');
  render();
}

resetBtn.addEventListener('click', resetGame);
undoBtn.addEventListener('click', undo);

modeSel.addEventListener('change', ()=>{
  state.mode = modeSel.value;
  updateUI();
  resetGame();
});

aiLevelSel.addEventListener('change', ()=>{ 
  state.aiLevel = +aiLevelSel.value; 
});

window.addEventListener('keydown', (e)=>{
  if (e.key==='r' || e.key==='R') resetBtn.click();
  if (e.key==='u' || e.key==='U') undo();
});

console.log('‚è≥ Initialisation...');
loadTheme();
fullRender();
modeSel.value = state.mode;
aiLevelSel.value = String(state.aiLevel);
updateUI();
startChrono();
console.log('‚úÖ Jeu pr√™t !');
</script>

</body>
</html>
