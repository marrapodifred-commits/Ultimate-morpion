<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="theme-color" content="#0f172a">
<title>Ultimate Morpion</title>
<style>
  :root{
    --bg:#ffffff;
    --fg:#0f172a;
    --muted:#6b7280;
    --grid:#e5e7eb;
    --grid-strong:#cbd5e1;
    --x:#e53935;
    --o:#2563eb;
    --active:#f1f5f9;
    --accent:#111827;
    --accent-fg:#ffffff;
    --win:#10b981;
    --size:min(92vmin, 900px);
    --mini-gap:10px;
  }

  [data-theme="dark"] {
    --bg:#0f172a;
    --fg:#f1f5f9;
    --muted:#94a3b8;
    --grid:#334155;
    --grid-strong:#475569;
    --active:#1e293b;
    --accent:#f1f5f9;
    --accent-fg:#0f172a;
  }

  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;width:100%}
  body{
    background:var(--bg); 
    color:var(--fg);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    display:flex; 
    flex-direction:column; 
    align-items:center; 
    gap:14px; 
    padding:14px 10px 28px;
    overflow-x:hidden;
  }

  header, .bar { 
    width:100%;
    max-width:1200px;
  }

  header{ 
    display:flex; 
    flex-wrap:wrap; 
    align-items:center; 
    justify-content:space-between; 
    gap:12px; 
  }
  
  header h1{ 
    font-size:20px; 
    font-weight:800; 
  }

  .controls{ 
    display:flex; 
    flex-wrap:wrap; 
    gap:8px; 
    align-items:center; 
  }
  
  select, input, button{
    font:inherit; 
    border:1px solid var(--grid-strong); 
    border-radius:10px; 
    padding:8px 10px; 
    background:var(--bg); 
    color:var(--fg);
    cursor:pointer;
  }
  
  button{
    display:inline-flex;
    align-items:center;
    gap:6px;
    font-size:20px;
  }
  
  button.accent{ 
    background:var(--accent); 
    color:var(--accent-fg); 
    border:none; 
    font-weight:600; 
  }
  
  button:disabled{ 
    opacity:.6; 
    cursor:not-allowed; 
  }

  #themeToggle{
    padding:8px 12px;
    background:var(--accent);
    color:var(--accent-fg);
    border:none;
    border-radius:10px;
    font-size:20px;
  }

  .bar{
    display:flex; 
    align-items:center; 
    justify-content:space-between; 
    gap:10px; 
    flex-wrap:wrap;
    padding:8px 0;
    width:100%;
  }
  
  .status{
    padding:8px 12px; 
    border:1px dashed var(--grid-strong); 
    border-radius:10px; 
    background:var(--bg);
    display:flex; 
    align-items:center; 
    gap:10px; 
    min-height:40px;
  }
  
  .badge{ 
    padding:4px 8px; 
    border-radius:999px; 
    font-weight:700; 
    background:var(--active); 
    border:1px solid var(--grid-strong); 
  }
  
  .dot{ 
    width:10px; 
    height:10px; 
    border-radius:50%; 
    display:inline-block; 
    margin-right:6px; 
  }
  
  .dot.x{ background:var(--x); } 
  .dot.o{ background:var(--o); }
  .small{ color:var(--muted); font-size:12px }

  #chronoDisplay, #timerDisplay {
    font-size:20px;
    font-weight:600;
    padding:8px 16px;
    background:var(--active);
    border:2px solid var(--grid-strong);
    border-radius:12px;
    min-width:80px;
    text-align:center;
    color:var(--muted);
  }

  #timerDisplay.warning {
    color: #f59e0b;
    animation: timerPulse 1s ease-in-out infinite;
  }
  #timerDisplay.critical {
    color: #ef4444;
    animation: timerPulse 0.5s ease-in-out infinite;
  }
  @keyframes timerPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }

  .player-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: var(--active);
    border: 2px solid var(--grid-strong);
    border-radius: 12px;
    font-weight: 600;
  }

  .player-indicator .side-badge {
    padding: 4px 10px;
    border-radius: 8px;
    font-weight: 700;
    font-size: 14px;
  }

  .player-indicator .side-badge.x {
    background: var(--x);
    color: white;
  }

  .player-indicator .side-badge.o {
    background: var(--o);
    color: white;
  }

  .player-indicator .turn-text {
    font-size: 14px;
  }

  .player-indicator .turn-text.your-turn {
    color: var(--win);
    animation: pulse 1.5s ease-in-out infinite;
  }

  .player-indicator .turn-text.waiting {
    color: var(--muted);
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }

  .board{
    width:var(--size); 
    height:var(--size);
    display:grid; 
    grid-template-columns:repeat(3,1fr); 
    grid-template-rows:repeat(3,1fr);
    gap:var(--mini-gap);
    margin:20px auto;
  }
  
  .mini{
    position:relative; 
    background:var(--bg); 
    border:3px solid var(--grid-strong); 
    border-radius:12px; 
    overflow:hidden;
    display:grid; 
    grid-template-columns:repeat(3,1fr); 
    grid-template-rows:repeat(3,1fr);
  }
  
  .mini.active{ 
    background:#f0fdf4; 
    border-color:#10b981; 
    box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2);
  }
  
  [data-theme="dark"] .mini.active {
    background:#064e3b;
  }

  .mini.won .cell {
    filter: grayscale(35%) brightness(0.92);
    opacity: 0.85;
  }

  .cell{
    position:relative; 
    border:1px solid var(--grid); 
    display:flex; 
    align-items:center; 
    justify-content:center; 
    cursor:pointer;
    background:var(--bg); 
    min-height:30px;
  }
  
  .cell:hover{ 
    background:var(--active); 
  }
  
  .cell.disabled{ 
    pointer-events:none; 
    background:var(--active); 
  }

  .cell .mark{ 
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 70%;
    height: 70%;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .cell .mark svg{ 
    width: 100%; 
    height: 100%; 
    stroke: currentColor; 
    fill: none;
    stroke-linecap: round;
    stroke-linejoin: round;
    stroke-width: 3;
  }
  
  .cell .mark.x{ color:var(--x); }
  .cell .mark.o{ color:var(--o); }

  .winnerOverlay{
    position:absolute; 
    inset:4px; 
    pointer-events:none; 
    z-index:5; 
    display:flex; 
    align-items:center; 
    justify-content:center;
  }
  
  .winnerOverlay svg{ 
    width:85%; 
    height:85%; 
    fill:none; 
    stroke-linecap:round; 
    stroke-linejoin:round; 
    stroke-width:5;
  }
  
  .mini.winX .winnerOverlay svg{ 
    stroke:var(--x); 
  }
  
  .mini.winO .winnerOverlay svg{ 
    stroke:var(--o); 
  }

  .end-overlay {
    position: fixed;
    inset: 0;
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.4s ease;
  }

  .end-overlay.show {
    opacity: 1;
    pointer-events: all;
  }

  .end-backdrop {
    position: absolute;
    inset: 0;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
  }

  .end-overlay.victory .end-backdrop {
    background: radial-gradient(circle at 50% 50%, rgba(16, 185, 129, 0.15), rgba(34, 197, 94, 0.05));
    animation: victoryPulse 2s ease-in-out infinite;
  }

  .end-overlay.defeat .end-backdrop {
    background: radial-gradient(circle at 50% 50%, rgba(220, 38, 38, 0.12), rgba(239, 68, 68, 0.04));
    animation: defeatShake 0.5s ease-in-out;
  }

  .end-overlay.draw .end-backdrop {
    background: radial-gradient(circle at 50% 50%, rgba(107, 114, 128, 0.12), rgba(156, 163, 175, 0.04));
  }

  @keyframes victoryPulse {
    0%, 100% { transform: scale(1); opacity: 0.8; }
    50% { transform: scale(1.02); opacity: 1; }
  }

  @keyframes defeatShake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-10px); }
    75% { transform: translateX(10px); }
  }

  .end-card {
    position: relative;
    background: var(--bg);
    border-radius: 24px;
    padding: 48px 36px;
    max-width: 500px;
    width: 90%;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    text-align: center;
    transform: scale(0.8);
    animation: cardAppear 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
  }

  @keyframes cardAppear {
    to {
      transform: scale(1);
    }
  }

  .end-icon {
    font-size: 80px;
    margin-bottom: 20px;
    animation: iconBounce 0.6s ease-out 0.3s;
  }

  @keyframes iconBounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-20px); }
  }

  .end-title {
    font-size: 32px;
    font-weight: 800;
    margin: 0 0 12px 0;
    color: var(--fg);
  }

  .end-message {
    font-size: 16px;
    color: var(--muted);
    margin: 0 0 24px 0;
  }

  .end-stats {
    display: flex;
    justify-content: center;
    gap: 32px;
    margin-bottom: 32px;
  }

  .stat-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
  }

  .stat-value {
    font-size: 36px;
    font-weight: 800;
  }

  .stat-value.x {
    color: var(--x);
  }

  .stat-value.o {
    color: var(--o);
  }

  .stat-label {
    font-size: 12px;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .end-actions {
    display: flex;
    gap: 12px;
    justify-content: center;
  }

  .end-btn {
    padding: 14px 28px;
    font-size: 16px;
    font-weight: 700;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  .end-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  }

  .end-btn.primary {
    background: linear-gradient(135deg, #2563eb, #1d4ed8);
    color: white;
  }

  .end-btn.secondary {
    background: var(--bg);
    color: var(--fg);
    border: 2px solid var(--grid-strong);
  }

  .confetti {
    position: absolute;
    width: 10px;
    height: 10px;
    background: #10b981;
    opacity: 0;
  }

  .victory .confetti {
    animation: confettiFall 3s ease-out forwards;
  }

  @keyframes confettiFall {
    0% {
      transform: translateY(-100vh) rotate(0deg);
      opacity: 1;
    }
    100% {
      transform: translateY(100vh) rotate(720deg);
      opacity: 0;
    }
  }

  .hide{ display:none !important; }
  .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .grow{ flex:1; min-width:200px; }

  @media (max-width: 768px) {
    body {
      padding: 8px 5px 20px;
    }

    header h1 {
      font-size: 18px;
      width: 100%;
      text-align: center;
    }

    .controls {
      width: 100%;
      justify-content: center;
      font-size: 14px;
    }

    .board {
      --size: min(95vmin, 95vw);
      --mini-gap: 6px;
    }

    .end-card {
      padding: 32px 24px;
      width: 95%;
    }

    .end-icon {
      font-size: 60px;
    }

    .end-title {
      font-size: 24px;
    }
  }
</style>
</head>
<body>

<header>
  <h1>üéÆ Ultimate Morpion</h1>
  <div class="controls">
    <button id="themeToggle" type="button">üåì</button>
    
    <label>Mode :
      <select id="modeSel">
        <option value="local">Local 2 joueurs</option>
        <option value="ai">VS IA</option>
        <option value="online">En ligne</option>
        <option value="blitz-local">Blitz local</option>
        <option value="blitz-online">Blitz en ligne</option>
      </select>
    </label>

    <span id="aiWrap" class="row hide">
      <label>Niveau IA :
        <select id="aiLevelSel">
          <option value="1">Niveau 1</option>
          <option value="2">Niveau 2</option>
          <option value="3" selected>Niveau 3</option>
          <option value="4">Niveau 4</option>
          <option value="5">Niveau 5</option>
        </select>
      </label>
    </span>

    <span id="netWrap" class="row hide">
      <label>Serveur WS :
        <input id="wsUrl" type="text" value="wss://ultimate-ttt-ws.onrender.com">
      </label>
    </span>

    <span id="roomWrap" class="row hide">
      <label>Salle :
        <input id="room" type="text" placeholder="ex: amis2025">
      </label>
      <button id="joinBtn" class="accent" type="button">üîó Rejoindre</button>
    </span>

    <button id="resetBtn" type="button">üîÑ</button>
    <button id="undoBtn" type="button">‚Ü©Ô∏è</button>
  </div>
</header>

<div class="bar">
  <div id="status" class="status grow">
    <span class="badge"><span class="dot x"></span>Tour : X</span>
    <span id="activeMiniText" class="small">Mini impos√© : libre</span>
  </div>
  <div class="row">
    <span id="chronoDisplay" class="hide">0:00</span>
    <span id="timerDisplay" class="hide">30s</span>
    <div id="playerIndicator" class="player-indicator hide">
      <span class="side-badge x" id="playerSide">X</span>
      <span class="turn-text your-turn" id="turnText">√Ä vous de jouer !</span>
    </div>
  </div>
</div>

<div id="board" class="board"></div>

<div id="endOverlay" class="end-overlay">
  <div class="end-backdrop"></div>
  <div class="end-card">
    <div class="end-icon" id="endIcon">üèÜ</div>
    <h2 class="end-title" id="endTitle">Victoire !</h2>
    <p class="end-message" id="endMessage">F√©licitations !</p>
    <div class="end-stats">
      <div class="stat-item">
        <span class="stat-value x" id="statX">0</span>
        <span class="stat-label">Minis X</span>
      </div>
      <div class="stat-item">
        <span class="stat-value o" id="statO">0</span>
        <span class="stat-label">Minis O</span>
      </div>
    </div>
    <div class="end-actions">
      <button class="end-btn primary" id="endReplay" type="button">üîÑ Rejouer</button>
      <button class="end-btn secondary" id="endClose" type="button">‚úñÔ∏è Fermer</button>
    </div>
  </div>
</div>

<script>
console.log('üéÆ D√©marrage Ultimate Morpion...');

const LINES = [
  [0,1,2],[3,4,5],[6,7,8],
  [0,3,6],[1,4,7],[2,5,8],
  [0,4,8],[2,4,6]
];

const state = {
  board: Array.from({length:9},()=>Array(9).fill(null)),
  miniStatus: Array(9).fill(null),
  current: 'X',
  forcedMini: null,
  globalWin: null,
  history: [],
  mode: 'local',
  aiLevel: 3,
  net: { ws:null, url:'', room:'', side:null, connected:false },
  timer: null,
  timeLeft: 30,
  chrono: null,
  chronoTime: 0,
  theme: 'light'
};

const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const activeMiniTextEl = document.getElementById('activeMiniText');
const modeSel = document.getElementById('modeSel');
const aiLevelSel = document.getElementById('aiLevelSel');
const aiWrap = document.getElementById('aiWrap');
const netWrap = document.getElementById('netWrap');
const roomWrap = document.getElementById('roomWrap');
const wsUrlInput = document.getElementById('wsUrl');
const roomInput = document.getElementById('room');
const joinBtn = document.getElementById('joinBtn');
const resetBtn = document.getElementById('resetBtn');
const undoBtn = document.getElementById('undoBtn');
const themeToggle = document.getElementById('themeToggle');
const chronoDisplay = document.getElementById('chronoDisplay');
const timerDisplay = document.getElementById('timerDisplay');
const playerIndicator = document.getElementById('playerIndicator');
const playerSide = document.getElementById('playerSide');
const turnText = document.getElementById('turnText');
const endOverlay = document.getElementById('endOverlay');
const endIcon = document.getElementById('endIcon');
const endTitle = document.getElementById('endTitle');
const endMessage = document.getElementById('endMessage');
const statX = document.getElementById('statX');
const statO = document.getElementById('statO');
const endReplay = document.getElementById('endReplay');
const endClose = document.getElementById('endClose');

function loadTheme() {
  const saved = localStorage.getItem('theme') || 'light';
  state.theme = saved;
  document.documentElement.setAttribute('data-theme', saved);
  themeToggle.textContent = saved === 'dark' ? '‚òÄÔ∏è' : 'üåì';
}

themeToggle.addEventListener('click', () => {
  state.theme = state.theme === 'light' ? 'dark' : 'light';
  document.documentElement.setAttribute('data-theme', state.theme);
  localStorage.setItem('theme', state.theme);
  themeToggle.textContent = state.theme === 'dark' ? '‚òÄÔ∏è' : 'üåì';
});

function startTimer() {
  stopTimer();
  state.timeLeft = 30;
  updateTimerDisplay();
  state.timer = setInterval(() => {
    state.timeLeft--;
    updateTimerDisplay();
    if (state.timeLeft <= 0) {
      stopTimer();
      handleTimeout();
    }
  }, 1000);
}

function stopTimer() {
  if (state.timer) {
    clearInterval(state.timer);
    state.timer = null;
  }
}

function updateTimerDisplay() {
  timerDisplay.textContent = state.timeLeft + 's';
  timerDisplay.classList.remove('warning', 'critical');
  if (state.timeLeft <= 5) timerDisplay.classList.add('critical');
  else if (state.timeLeft <= 10) timerDisplay.classList.add('warning');
}

function handleTimeout() {
  state.current = state.current === 'X' ? 'O' : 'X';
  if (state.mode === 'blitz-online' && state.net.connected) {
    sendNet({ t: 'timeout', room: state.net.room });
  }
  render();
  if ((state.mode === 'blitz-local' || state.mode === 'blitz-online') && !state.globalWin) {
    startTimer();
  }
}

function startChrono() {
  if (state.chrono) return;
  state.chronoTime = 0;
  updateChronoDisplay();
  state.chrono = setInterval(() => {
    state.chronoTime++;
    updateChronoDisplay();
  }, 1000);
}

function stopChrono() {
  if (state.chrono) {
    clearInterval(state.chrono);
    state.chrono = null;
  }
}

function updateChronoDisplay() {
  const minutes = Math.floor(state.chronoTime / 60);
  const seconds = state.chronoTime % 60;
  chronoDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

function updatePlayerIndicator() {
  if (state.mode === 'online' || state.mode === 'blitz-online') {
    if (state.net.side === 'X' || state.net.side === 'O') {
      playerIndicator.classList.remove('hide');
      playerSide.textContent = state.net.side;
      playerSide.className = `side-badge ${state.net.side.toLowerCase()}`;
      if (state.current === state.net.side && !state.globalWin) {
        turnText.textContent = 'üéØ √Ä vous de jouer !';
        turnText.className = 'turn-text your-turn';
      } else if (state.globalWin) {
        turnText.textContent = 'Partie termin√©e';
        turnText.className = 'turn-text waiting';
      } else {
        turnText.textContent = '‚è≥ En attente...';
        turnText.className = 'turn-text waiting';
      }
    } else {
      playerIndicator.classList.add('hide');
    }
  } else {
    playerIndicator.classList.add('hide');
  }
}

function cellMark(player){
  if (player==='X'){
    return `<span class="mark x"><svg viewBox="0 0 24 24"><path d="M5 5L19 19"></path><path d="M19 5L5 19"></path></svg></span>`;
  } else {
    return `<span class="mark o"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="8"></circle></svg></span>`;
  }
}

function bigOverlaySVG(player){
  if (player==='X'){
    return {
      colorClass:'winX',
      shape:`<svg viewBox="0 0 24 24"><path d="M5 5L19 19"></path><path d="M19 5L5 19"></path></svg>`
    };
  } else {
    return {
      colorClass:'winO',
      shape:`<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="8"></circle></svg>`
    };
  }
}

function fullRender(){
  console.log('üé® Cr√©ation du plateau...');
  boardEl.innerHTML = '';
  
  for (let m=0; m<9; m++){
    const miniEl = document.createElement('div');
    miniEl.className = 'mini';
    miniEl.dataset.mini = m;

    for (let c=0; c<9; c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.m = m;
      cell.dataset.c = c;
      cell.addEventListener('click', onCellClick);
      miniEl.appendChild(cell);
    }

    boardEl.appendChild(miniEl);
  }
  
  console.log('‚úÖ Plateau cr√©√© !');
  render();
}

function render(){
  for (let m=0; m<9; m++){
    const miniEl = boardEl.children[m];
    if (!miniEl) continue;
    
    const miniWon = state.miniStatus[m];
    const isActive = isMiniPlayable(m);
    miniEl.classList.toggle('active', isActive && !state.globalWin);

    for (let c=0; c<9; c++){
      const cell = miniEl.children[c];
      if (!cell) continue;
      
      const canPlay = !state.globalWin && isActive && !state.board[m][c];
      cell.classList.toggle('disabled', !canPlay);
      cell.innerHTML = '';
      
      if (state.board[m][c]){
        cell.innerHTML = cellMark(state.board[m][c]);
      }
    }

    miniEl.classList.remove('winX','winO','won');
    const prevOverlay = miniEl.querySelector('.winnerOverlay');
    if (prevOverlay) prevOverlay.remove();
    
    if (miniWon==='X' || miniWon==='O'){
      const { colorClass, shape } = bigOverlaySVG(miniWon);
      miniEl.classList.add(colorClass);
      miniEl.classList.add('won');
      
      const ov = document.createElement('div');
      ov.className = 'winnerOverlay';
      ov.innerHTML = shape;
      miniEl.appendChild(ov);
    }
  }

  const cur = state.current;
  const dot = `<span class="dot ${cur.toLowerCase()}"></span>`;
  
  if (!state.globalWin){
    statusEl.innerHTML = `<span class="badge">${dot}Tour : ${cur}</span>`;
  } else if (state.globalWin==='D'){
    statusEl.innerHTML = `<span class="badge">Match nul</span>`;
  } else {
    const winner = state.globalWin;
    const wdot = `<span class="dot ${winner.toLowerCase()}"></span>`;
    statusEl.innerHTML = `<span class="badge">${wdot}${winner} a gagn√© !</span>`;
  }

  if (state.forcedMini===null){
    activeMiniTextEl.textContent = 'Mini impos√© : libre';
  } else {
    activeMiniTextEl.textContent = `Mini impos√© : ${state.forcedMini+1}`;
  }

  updatePlayerIndicator();
}

function isMiniPlayable(m){
  if (state.forcedMini!==null) return state.forcedMini===m;
  return !state.miniStatus[m];
}

function checkLine3(arr, player){
  return LINES.some(([a,b,c])=>arr[a]===player && arr[b]===player && arr[c]===player);
}

function miniWinner(m){
  const grid = state.board[m];
  if (checkLine3(grid,'X')) return 'X';
  if (checkLine3(grid,'O')) return 'O';
  if (grid.every(v=>v!==null)) return 'D';
  return null;
}

function isMiniFull(m){ 
  return state.board[m].every(v=>v!==null); 
}

function updateMiniAndGlobal(m){
  const win = miniWinner(m);
  if (win && !state.miniStatus[m]) state.miniStatus[m] = win;
  
  const macro = Array(9).fill(null).map((_,i)=>{
    return state.miniStatus[i]==='X' ? 'X' : state.miniStatus[i]==='O' ? 'O' : null;
  });
  
  if (checkLine3(macro,'X')) state.globalWin = 'X';
  else if (checkLine3(macro,'O')) state.globalWin = 'O';
  else if (state.miniStatus.every(s=>s)) state.globalWin = 'D';
  
  if (state.globalWin) {
    stopChrono();
    stopTimer();
    setTimeout(() => showEndAnimation(), 500);
  }
}

function applyMove(m,c,fromPlayer=null){
  const player = fromPlayer || state.current;
  if (state.globalWin) return false;
  if (state.board[m][c]!==null) return false;
  if (!isMiniPlayable(m)) return false;

  state.board[m][c] = player;
  
  state.history.push({ 
    m, c, player, 
    prevForced: state.forcedMini, 
    prevMiniStatus: state.miniStatus.slice(), 
    prevGlobal: state.globalWin 
  });

  updateMiniAndGlobal(m);

  const targetMini = c;
  if (state.miniStatus[targetMini] || isMiniFull(targetMini)){
    state.forcedMini = null;
  } else {
    state.forcedMini = targetMini;
  }

  state.current = state.current==='X' ? 'O' : 'X';

  if ((state.mode === 'blitz-local' || state.mode === 'blitz-online') && !state.globalWin) {
    startTimer();
  }

  return true;
}

function resetGame(){
  stopChrono();
  stopTimer();
  state.board = Array.from({length:9},()=>Array(9).fill(null));
  state.miniStatus = Array(9).fill(null);
  state.current = 'X';
  state.forcedMini = null;
  state.globalWin = null;
  state.history = [];
  fullRender();
  
  if (state.mode === 'blitz-local' || state.mode === 'blitz-online') {
    startTimer();
  } else if (state.mode === 'local' || state.mode === 'online') {
    startChrono();
  }
}

function undo(){
  if (state.mode==='online' || state.mode==='blitz-local' || state.mode==='blitz-online') return;
  if (state.history.length===0) return;
  const last = state.history.pop();
  state.board[last.m][last.c] = null;
  state.forcedMini = last.prevForced;
  state.miniStatus = last.prevMiniStatus;
  state.globalWin = last.prevGlobal;
  state.current = last.player;
  render();
}

function cloneState(){
  return {
    board: state.board.map(mini=>mini.slice()),
    miniStatus: state.miniStatus.slice(),
    current: state.current,
    forcedMini: state.forcedMini,
    globalWin: state.globalWin
  };
}

function restoreState(snap){
  state.board = snap.board;
  state.miniStatus = snap.miniStatus;
  state.current = snap.current;
  state.forcedMini = snap.forcedMini;
  state.globalWin = snap.globalWin;
}

function getPossibleMoves(){
  if (state.globalWin) return [];
  const moves = [];
  if (state.forcedMini!==null){
    const m = state.forcedMini;
    if (!state.miniStatus[m]){
      for (let c=0;c<9;c++){
        if (!state.board[m][c]) moves.push({m,c});
      }
    }
  } else {
    for (let m=0;m<9;m++){
      if (state.miniStatus[m]) continue;
      for (let c=0;c<9;c++){
        if (!state.board[m][c]) moves.push({m,c});
      }
    }
  }
  return moves;
}

function evaluate(){
  let score = 0;
  for (let m=0;m<9;m++){
    if (state.miniStatus[m]==='X') score+=3;
    else if (state.miniStatus[m]==='O') score-=3;
  }
  if (state.globalWin==='X') score+=999;
  else if (state.globalWin==='O') score-=999;
  return score;
}

function aiMove(){
  const depth = state.aiLevel;
  const moves = getPossibleMoves();
  if (moves.length===0) return null;
  
  let bestMove = null;
  let bestVal = -Infinity;

  for (const mv of moves){
    const snapshot = cloneState();
    applyMove(mv.m, mv.c, state.current);
    const val = minimax(depth-1, -Infinity, Infinity);
    restoreState(snapshot);
    if (val > bestVal){
      bestVal = val;
      bestMove = mv;
    }
  }
  return bestMove;
}

function minimax(depth, alpha, beta){
  if (depth===0 || state.globalWin) return evaluate();
  const moves = getPossibleMoves();
  if (moves.length===0) return evaluate();

  const me = state.current;
  if (me==='X'){
    let value = -Infinity;
    for (const mv of moves){
      const snapshot = cloneState();
      applyMove(mv.m, mv.c, me);
      value = Math.max(value, minimax(depth-1, alpha, beta));
      restoreState(snapshot);
      alpha = Math.max(alpha, value);
      if (beta<=alpha) break;
    }
    return value;
  } else {
    let value = Infinity;
    for (const mv of moves){
      const snapshot = cloneState();
      applyMove(mv.m, mv.c, me);
      value = Math.min(value, minimax(depth-1, alpha, beta));
      restoreState(snapshot);
      beta = Math.min(beta, value);
      if (beta<=alpha) break;
    }
    return value;
  }
}

function onCellClick(e){
  const m = +e.currentTarget.dataset.m;
  const c = +e.currentTarget.dataset.c;

  if (!isLocalTurnForThisClient()) return;
  if (!applyMove(m,c)) return;

  if ((state.mode==='online' || state.mode==='blitz-online') && state.net.connected){
    sendNet({ t:'move', room: state.net.room, data:{ m, c } });
  }

  render();
  
  if (state.mode === 'ai' && !state.globalWin && state.current === 'O') {
    setTimeout(()=>{
      const mv = aiMove();
      if (mv){
        applyMove(mv.m, mv.c);
        render();
      }
    }, 300);
  }
}

function isLocalTurnForThisClient(){
  if (state.globalWin) return false;
  if (state.mode==='online' || state.mode==='blitz-online'){
    if (state.net.side==='X' || state.net.side==='O'){
      return state.current===state.net.side;
    }
    return true;
  }
  return true;
}

function connectWS(url){
  try{ 
    if (state.net.ws) state.net.ws.close(); 
  }catch(e){}
  
  const ws = new WebSocket(url);
  state.net.ws = ws;
  
  ws.onopen = ()=>{
    console.log('‚úÖ WebSocket connect√©');
    state.net.connected = true;
    state.net.url = url;
    sendNet({ t:'join', room: state.net.room });
    updateUI();
    
    if (state.mode === 'blitz-online') {
      startTimer();
    } else if (state.mode === 'online') {
      startChrono();
    }
  };
  
  ws.onmessage = (evt)=>{
    try{
      const msg = JSON.parse(evt.data);
      handleNetMsg(msg);
    }catch(e){}
  };
  
  ws.onerror = (err)=>{ 
    console.error('‚ùå Erreur WebSocket');
    state.net.connected=false; 
    updateUI(); 
  };
  
  ws.onclose = ()=>{ 
    console.log('üîå WebSocket ferm√©');
    state.net.connected=false; 
    state.net.side=null;
    stopTimer();
    stopChrono();
    updateUI(); 
  };
}

function sendNet(obj){
  if (!state.net.ws || state.net.ws.readyState!==WebSocket.OPEN) return;
  state.net.ws.send(JSON.stringify(obj));
}

function handleNetMsg(msg){
  if (msg.t==='joined'){
    state.net.side = msg.side;
    updateUI();
    updatePlayerIndicator();
  } else if (msg.t==='state'){
    state.board = msg.data.board;
    state.miniStatus = msg.data.miniStatus;
    state.current = msg.data.current;
    state.forcedMini = msg.data.forcedMini;
    state.globalWin = msg.data.globalWin;
    state.history = [];
    render();
  } else if (msg.t==='move'){
    const {m,c} = msg.data;
    applyMove(m,c);
    render();
  } else if (msg.t==='reset'){
    resetGame();
  } else if (msg.t==='timeout'){
    handleTimeout();
  }
}

function updateUI(){
  aiWrap.classList.toggle('hide', state.mode!=='ai');
  netWrap.classList.toggle('hide', state.mode!=='online' && state.mode!=='blitz-online');
  roomWrap.classList.toggle('hide', state.mode!=='online' && state.mode!=='blitz-online');
  undoBtn.disabled = state.mode==='online' || state.mode==='blitz-local' || state.mode==='blitz-online';
  
  timerDisplay.classList.toggle('hide', state.mode!=='blitz-local' && state.mode!=='blitz-online');
  chronoDisplay.classList.toggle('hide', state.mode!=='local' && state.mode!=='online');
  
  updatePlayerIndicator();
  
  if (state.mode === 'online' || state.mode === 'blitz-online') {
    if (state.net.connected) {
      joinBtn.innerHTML = '‚úÖ Connect√©';
      joinBtn.disabled = true;
    } else {
      joinBtn.innerHTML = 'üîó Rejoindre';
      joinBtn.disabled = false;
    }
  }
  
  render();
}

function showEndAnimation() {
  if (!state.globalWin) return;

  let x = 0, o = 0;
  for (const s of state.miniStatus) {
    if (s === 'X') x++;
    if (s === 'O') o++;
  }
  
  statX.textContent = x;
  statO.textContent = o;

  endOverlay.classList.remove('victory', 'defeat', 'draw');

  if (state.globalWin === 'X') {
    endOverlay.classList.add('victory');
    endIcon.textContent = 'üèÜ';
    endTitle.textContent = 'Victoire !';
    endMessage.textContent = 'X a gagn√© la partie !';
    createConfetti();
  } else if (state.globalWin === 'O') {
    endOverlay.classList.add('defeat');
    endIcon.textContent = 'üòî';
    endTitle.textContent = 'D√©faite';
    endMessage.textContent = 'O a gagn√© la partie !';
  } else {
    endOverlay.classList.add('draw');
    endIcon.textContent = 'ü§ù';
    endTitle.textContent = 'Match nul';
    endMessage.textContent = 'Partie serr√©e !';
  }

  setTimeout(() => {
    endOverlay.classList.add('show');
  }, 100);
}

function createConfetti() {
  const colors = ['#10b981', '#3b82f6', '#f59e0b', '#ef4444', '#8b5cf6'];
  for (let i = 0; i < 50; i++) {
    setTimeout(() => {
      const confetti = document.createElement('div');
      confetti.className = 'confetti';
      confetti.style.left = Math.random() * 100 + '%';
      confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
      confetti.style.animationDelay = Math.random() * 0.3 + 's';
      confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
      endOverlay.appendChild(confetti);
      setTimeout(() => confetti.remove(), 3500);
    }, i * 30);
  }
}

function hideEndAnimation() {
  endOverlay.classList.remove('show');
  setTimeout(() => {
    endOverlay.classList.remove('victory', 'defeat', 'draw');
    endOverlay.querySelectorAll('.confetti').forEach(c => c.remove());
  }, 400);
}

resetBtn.addEventListener('click', ()=>{
  hideEndAnimation();
  resetGame();
  if ((state.mode==='online' || state.mode==='blitz-online') && state.net.connected){
    sendNet({ t:'reset', room: state.net.room });
  }
});

undoBtn.addEventListener('click', undo);

modeSel.addEventListener('change', ()=>{
  const oldMode = state.mode;
  state.mode = modeSel.value;
  
  if (oldMode === 'blitz-local' || oldMode === 'blitz-online') stopTimer();
  if (oldMode === 'local' || oldMode === 'online') stopChrono();
  if ((oldMode === 'online' || oldMode === 'blitz-online') && state.net.connected) {
    state.net.ws.close();
    state.net.connected = false;
    state.net.side = null;
  }
  
  updateUI();
  resetGame();
});

aiLevelSel.addEventListener('change', ()=>{ 
  state.aiLevel = +aiLevelSel.value; 
});

joinBtn.addEventListener('click', (e)=>{
  e.preventDefault();
  const url = wsUrlInput.value.trim();
  const room = roomInput.value.trim();
  if (!url || !room) {
    alert('‚ö†Ô∏è Veuillez remplir le serveur et la salle');
    return;
  }
  state.net.room = room;
  connectWS(url);
});

endReplay.addEventListener('click', () => {
  hideEndAnimation();
  resetGame();
  if ((state.mode==='online' || state.mode==='blitz-online') && state.net.connected){
    sendNet({ t:'reset', room: state.net.room });
  }
});

endClose.addEventListener('click', () => {
  hideEndAnimation();
});

window.addEventListener('keydown', (e)=>{
  if (e.key==='r' || e.key==='R') resetBtn.click();
  if (e.key==='u' || e.key==='U') undo();
  if (e.key === 'Escape' && endOverlay.classList.contains('show')) {
    hideEndAnimation();
  }
});

console.log('‚è≥ Initialisation...');
loadTheme();
fullRender();
modeSel.value = state.mode;
aiLevelSel.value = String(state.aiLevel);
updateUI();

if (state.mode === 'local') {
  startChrono();
}

console.log('‚úÖ Jeu pr√™t !');
</script>

</body>
</html>
