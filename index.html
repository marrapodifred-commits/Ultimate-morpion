<!doctype html>

<html lang="fr">
<head>
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="theme-color" content="#0f172a">
<meta name="description" content="Ultimate Morpion - Jouez au morpion ultime en ligne ou hors ligne">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Ultimate Morpion">
<title>Ultimate Morpion</title>
<link rel="manifest" id="manifest-link">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%230f172a' width='100' height='100' rx='20'/><text x='50' y='70' font-size='60' text-anchor='middle' fill='%23fff'>üéÆ</text></svg>">
<style>
  :root{
    --bg:#ffffff;
    --fg:#0f172a;
    --muted:#6b7280;
    --grid:#e5e7eb;
    --grid-strong:#cbd5e1;
    --x:#e53935;
    --o:#2563eb;
    --active:#f1f5f9;
    --accent:#111827;
    --accent-fg:#ffffff;
    --win:#10b981;
    --size:min(92vmin, 900px);
    --mini-gap:10px;
  }

[data-theme=‚Äúdark‚Äù] {
‚Äìbg:#0f172a;
‚Äìfg:#f1f5f9;
‚Äìmuted:#94a3b8;
‚Äìgrid:#334155;
‚Äìgrid-strong:#475569;
‚Äìactive:#1e293b;
‚Äìaccent:#f1f5f9;
‚Äìaccent-fg:#0f172a;
}

*{box-sizing:border-box}
html,body{height:100%}
body{
margin:0; background:var(‚Äìbg); color:var(‚Äìfg);
font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, ‚ÄúHelvetica Neue‚Äù, Arial, ‚ÄúNoto Sans‚Äù, sans-serif;
display:flex; flex-direction:column; align-items:center; gap:14px; padding:14px 10px 28px;
-webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
transition: background 0.3s ease, color 0.3s ease;
}

header, .bar { width:clamp(320px,96vw,1200px); }
header{ display:flex; flex-wrap:wrap; align-items:center; justify-content:space-between; gap:12px; }
header h1{ margin:0; font-size:20px; font-weight:800; letter-spacing:.2px }

.controls{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
select, input, button{
font:inherit; border:1px solid var(‚Äìgrid-strong); border-radius:10px; padding:8px 10px;
background:var(‚Äìbg); color:var(‚Äìfg);
cursor:pointer;
transition: all 0.2s ease;
}
button.accent{ background:var(‚Äìaccent); color:var(‚Äìaccent-fg); border-color:transparent; font-weight:600; }
button:disabled{ opacity:.6; cursor:not-allowed; }
button:hover:not(:disabled){ opacity:0.9; transform: translateY(-1px); }

button {
display: inline-flex;
align-items: center;
gap: 6px;
font-size: 20px;
}

#themeToggle, #installBtn {
padding: 8px 12px;
background: var(‚Äìaccent);
color: var(‚Äìaccent-fg);
border: none;
border-radius: 10px;
font-size: 20px;
cursor: pointer;
transition: all 0.2s ease;
}
#themeToggle:hover, #installBtn:hover {
transform: scale(1.1) rotate(15deg);
}

#installBtn {
display: none;
}

#installBtn.show {
display: inline-flex;
}

.bar{
display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;
padding:8px 0;
}
.status{
padding:8px 12px; border:1px dashed var(‚Äìgrid-strong); border-radius:10px; background:var(‚Äìbg);
display:flex; align-items:center; gap:10px; min-height:40px;
}
.badge{ padding:4px 8px; border-radius:999px; font-weight:700; background:var(‚Äìactive); border:1px solid var(‚Äìgrid-strong); }
.dot{ width:10px; height:10px; border-radius:50%; display:inline-block; margin-right:6px; vertical-align:middle; }
.dot.x{ background:var(‚Äìx); } .dot.o{ background:var(‚Äìo); }
.small{ color:var(‚Äìmuted); font-size:12px }

#chronoDisplay {
font-size: 20px;
font-weight: 600;
padding: 8px 16px;
background: var(‚Äìactive);
border: 2px solid var(‚Äìgrid-strong);
border-radius: 12px;
min-width: 80px;
text-align: center;
color: var(‚Äìmuted);
}

.player-indicator {
display: flex;
align-items: center;
gap: 8px;
padding: 8px 12px;
background: var(‚Äìactive);
border: 2px solid var(‚Äìgrid-strong);
border-radius: 12px;
font-weight: 600;
}

.player-indicator .side-badge {
padding: 4px 10px;
border-radius: 8px;
font-weight: 700;
font-size: 14px;
}

.player-indicator .side-badge.x {
background: var(‚Äìx);
color: white;
}

.player-indicator .side-badge.o {
background: var(‚Äìo);
color: white;
}

.player-indicator .turn-text {
font-size: 14px;
}

.player-indicator .turn-text.your-turn {
color: var(‚Äìwin);
animation: pulse 1.5s ease-in-out infinite;
}

.player-indicator .turn-text.waiting {
color: var(‚Äìmuted);
}

@keyframes pulse {
0%, 100% { opacity: 1; }
50% { opacity: 0.6; }
}

#timerDisplay {
font-size: 24px;
font-weight: 700;
padding: 8px 16px;
background: var(‚Äìactive);
border: 2px solid var(‚Äìgrid-strong);
border-radius: 12px;
min-width: 100px;
text-align: center;
}
#timerDisplay.warning {
color: #f59e0b;
animation: timerPulse 1s ease-in-out infinite;
}
#timerDisplay.critical {
color: #ef4444;
animation: timerPulse 0.5s ease-in-out infinite;
}
@keyframes timerPulse {
0%, 100% { transform: scale(1); }
50% { transform: scale(1.05); }
}

.board{
width:var(‚Äìsize); aspect-ratio:1/1; display:grid; grid-template-columns:repeat(3,1fr); grid-template-rows:repeat(3,1fr);
gap:var(‚Äìmini-gap);
}
.mini{
position:relative; background:var(‚Äìbg); border:3px solid var(‚Äìgrid-strong); border-radius:12px; overflow:hidden;
display:grid; grid-template-columns:repeat(3,1fr); grid-template-rows:repeat(3,1fr);
transition: all 0.3s ease;
}

.mini.active{
background:#f0fdf4;
border-color:#10b981;
box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2), inset 0 0 0 2px rgba(16, 185, 129, 0.1);
}

[data-theme=‚Äúdark‚Äù] .mini.active {
background:#064e3b;
box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.3), inset 0 0 0 2px rgba(16, 185, 129, 0.2);
}

.mini.won .cell {
filter: grayscale(35%) brightness(0.92);
opacity: 0.85;
}

.cell{
position:relative;
border:1px solid var(‚Äìgrid);
display:flex;
align-items:center;
justify-content:center;
cursor:pointer;
background:var(‚Äìbg);
transition:background .15s ease;
}
.cell:hover{ background:var(‚Äìactive); }
.cell.disabled{ pointer-events:none; background:var(‚Äìactive); }

.cell .mark{
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 70%;
height: 70%;
display: flex;
align-items: center;
justify-content: center;
pointer-events: none;
}
.cell .mark svg{
width: 100%;
height: 100%;
stroke: currentColor;
fill: none;
stroke-linecap: round;
stroke-linejoin: round;
stroke-width: 3;
}
.cell .mark.x{ color:var(‚Äìx); }
.cell .mark.o{ color:var(‚Äìo); }

.cell .ghost{
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 70%;
height: 70%;
display: flex;
align-items: center;
justify-content: center;
pointer-events: none;
opacity: .35;
filter: drop-shadow(0 2px 6px rgba(0,0,0,.08));
}
.cell .ghost svg{
width: 100%;
height: 100%;
display: block;
stroke: currentColor;
fill: none;
stroke-linecap: round;
stroke-linejoin: round;
stroke-width: 3;
}
.cell .ghost.x{ color: var(‚Äìx); }
.cell .ghost.o{ color: var(‚Äìo); }

.winnerOverlay{
position:absolute;
inset:4px;
pointer-events:none;
z-index:5;
display:flex;
align-items:center;
justify-content:center;
}
.winnerOverlay svg{
width:85%;
height:85%;
fill:none;
stroke-linecap:round;
stroke-linejoin:round;
stroke-width:5;
}
.mini.winX .winnerOverlay svg{
stroke:var(‚Äìx);
filter: drop-shadow(0 4px 12px rgba(229, 57, 53, 0.5));
}
.mini.winO .winnerOverlay svg{
stroke:var(‚Äìo);
filter: drop-shadow(0 4px 12px rgba(37, 99, 235, 0.5));
}

.mini.globalWin{ filter:brightness(1.1) saturate(1.3); transform:scale(1.02); }

.hide{ display:none !important; }
.row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
.grow{ flex:1; min-width:200px; }

.end-overlay {
position: fixed;
inset: 0;
z-index: 10000;
display: flex;
align-items: center;
justify-content: center;
opacity: 0;
pointer-events: none;
transition: opacity 0.4s ease;
}

.end-overlay.show {
opacity: 1;
pointer-events: all;
}

.end-backdrop {
position: absolute;
inset: 0;
backdrop-filter: blur(8px);
-webkit-backdrop-filter: blur(8px);
}

.end-overlay.victory .end-backdrop {
background: radial-gradient(circle at 50% 50%, rgba(16, 185, 129, 0.15), rgba(34, 197, 94, 0.05));
animation: victoryPulse 2s ease-in-out infinite;
}

.end-overlay.defeat .end-backdrop {
background: radial-gradient(circle at 50% 50%, rgba(220, 38, 38, 0.12), rgba(239, 68, 68, 0.04));
animation: defeatShake 0.5s ease-in-out;
}

.end-overlay.draw .end-backdrop {
background: radial-gradient(circle at 50% 50%, rgba(107, 114, 128, 0.12), rgba(156, 163, 175, 0.04));
}

@keyframes victoryPulse {
0%, 100% { transform: scale(1); opacity: 0.8; }
50% { transform: scale(1.02); opacity: 1; }
}

@keyframes defeatShake {
0%, 100% { transform: translateX(0); }
25% { transform: translateX(-10px); }
75% { transform: translateX(10px); }
}

.end-card {
position: relative;
background: var(‚Äìbg);
border-radius: 24px;
padding: 48px 36px;
max-width: 500px;
width: 90%;
box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
text-align: center;
transform: scale(0.8);
animation: cardAppear 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}

@keyframes cardAppear {
to {
transform: scale(1);
}
}

.end-icon {
font-size: 80px;
margin-bottom: 20px;
animation: iconBounce 0.6s ease-out 0.3s;
}

@keyframes iconBounce {
0%, 100% { transform: translateY(0); }
50% { transform: translateY(-20px); }
}

.end-title {
font-size: 32px;
font-weight: 800;
margin: 0 0 12px 0;
color: var(‚Äìfg);
}

.end-message {
font-size: 16px;
color: var(‚Äìmuted);
margin: 0 0 24px 0;
}

.end-stats {
display: flex;
justify-content: center;
gap: 32px;
margin-bottom: 32px;
}

.stat-item {
display: flex;
flex-direction: column;
align-items: center;
gap: 8px;
}

.stat-value {
font-size: 36px;
font-weight: 800;
}

.stat-value.x {
color: var(‚Äìx);
}

.stat-value.o {
color: var(‚Äìo);
}

.stat-label {
font-size: 12px;
color: var(‚Äìmuted);
text-transform: uppercase;
letter-spacing: 0.5px;
}

.end-actions {
display: flex;
gap: 12px;
justify-content: center;
}

.end-btn {
padding: 14px 28px;
font-size: 16px;
font-weight: 700;
border: none;
border-radius: 12px;
cursor: pointer;
transition: all 0.2s ease;
box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.end-btn:hover {
transform: translateY(-2px);
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.end-btn:active {
transform: translateY(0);
}

.end-btn.primary {
background: linear-gradient(135deg, #2563eb, #1d4ed8);
color: white;
}

.end-btn.secondary {
background: var(‚Äìbg);
color: var(‚Äìfg);
border: 2px solid var(‚Äìgrid-strong);
}

.confetti {
position: absolute;
width: 10px;
height: 10px;
background: #10b981;
opacity: 0;
}

.victory .confetti {
animation: confettiFall 3s ease-out forwards;
}

@keyframes confettiFall {
0% {
transform: translateY(-100vh) rotate(0deg);
opacity: 1;
}
100% {
transform: translateY(100vh) rotate(720deg);
opacity: 0;
}
}

@media (max-width: 768px) {
body {
padding: 8px 5px 20px;
gap: 10px;
}

```
header {
  gap: 8px;
}

header h1 {
  font-size: 18px;
  width: 100%;
  text-align: center;
}

.controls {
  width: 100%;
  justify-content: center;
  font-size: 14px;
}

select, input, button {
  padding: 10px 12px;
  font-size: 16px;
  touch-action: manipulation;
}

button {
  min-width: 44px;
  min-height: 44px;
  font-size: 22px;
}

#themeToggle, #installBtn {
  padding: 10px 14px;
  font-size: 22px;
}

.bar {
  flex-direction: column;
  gap: 8px;
}

.status {
  width: 100%;
  justify-content: center;
  text-align: center;
  flex-wrap: wrap;
}

.badge {
  font-size: 14px;
}

#timerDisplay {
  font-size: 20px;
  min-width: 80px;
}

#chronoDisplay {
  font-size: 18px;
  min-width: 70px;
}

.player-indicator {
  font-size: 13px;
  padding: 6px 10px;
}

.player-indicator .side-badge {
  font-size: 12px;
  padding: 3px 8px;
}

.board {
  --size: min(95vmin, 95vw);
  --mini-gap: 6px;
}

.mini {
  border-width: 2px;
  border-radius: 8px;
}

.end-card {
  padding: 32px 24px;
  width: 95%;
}

.end-icon {
  font-size: 60px;
}

.end-title {
  font-size: 24px;
}

.end-message {
  font-size: 14px;
}

.end-stats {
  gap: 24px;
  margin-bottom: 24px;
}

.stat-value {
  font-size: 28px;
}

.end-btn {
  padding: 12px 20px;
  font-size: 14px;
}

label {
  display: flex;
  flex-direction: column;
  gap: 4px;
  font-size: 14px;
}

.row {
  width: 100%;
  justify-content: center;
}

.grow {
  min-width: auto;
}
```

}

@media (max-width: 480px) {
header h1 {
font-size: 16px;
}

```
.controls {
  font-size: 13px;
}

button {
  font-size: 20px;
}

.badge {
  font-size: 12px;
  padding: 3px 6px;
}

.end-card {
  padding: 24px 16px;
}

.end-title {
  font-size: 20px;
}

.end-stats {
  gap: 16px;
}

.stat-value {
  font-size: 24px;
}
```

}

@media (hover: none) and (pointer: coarse) {
.cell {
cursor: default;
}

```
.cell:active {
  background: var(--active);
  transform: scale(0.95);
  transition: all 0.1s ease;
}

button:active {
  transform: scale(0.95);
}
```

}
</style>

</head>
<body>

<header>
  <h1>üéÆ Ultimate Morpion</h1>
  <div class="controls">
    <button id="installBtn" type="button" title="Installer l'application">üì±</button>
    <button id="themeToggle" type="button" title="Changer de th√®me">üåì</button>

```
<label>Mode :
  <select id="modeSel">
    <option value="local">Local 2 joueurs</option>
    <option value="ai">VS IA</option>
    <option value="online">En ligne</option>
    <option value="blitz-local">Blitz local</option>
    <option value="blitz-online">Blitz en ligne</option>
  </select>
</label>

<span id="aiWrap" class="row hide">
  <label>Niveau IA :
    <select id="aiLevelSel">
      <option value="1">Niveau 1</option>
      <option value="2">Niveau 2</option>
      <option value="3" selected>Niveau 3</option>
      <option value="4">Niveau 4</option>
      <option value="5">Niveau 5</option>
    </select>
  </label>
</span>

<span id="netWrap" class="row hide">
  <label>Serveur WS :
    <input id="wsUrl" type="text" value="wss://ultimate-ttt-ws.onrender.com">
  </label>
</span>

<span id="roomWrap" class="row hide">
  <label>Salle :
    <input id="room" type="text" placeholder="ex: amis2025">
  </label>
  <button id="joinBtn" class="accent" type="button">üîó Rejoindre</button>
</span>

<button id="resetBtn" type="button" title="Reset (R)">üîÑ</button>
<button id="undoBtn" type="button" title="Undo (U)">‚Ü©Ô∏è</button>
```

  </div>
</header>

<div class="bar">
  <div id="status" class="status grow">
    <span class="badge"><span class="dot x"></span>Tour : X</span>
    <span id="activeMiniText" class="small">Mini impos√© : libre</span>
  </div>
  <div class="row">
    <span id="chronoDisplay" class="hide">0:00</span>
    <span id="timerDisplay" class="hide">30s</span>
    <div id="playerIndicator" class="player-indicator hide">
      <span class="side-badge x" id="playerSide">X</span>
      <span class="turn-text your-turn" id="turnText">√Ä vous de jouer !</span>
    </div>
  </div>
</div>

<div id="board" class="board" aria-label="Ultimate Morpion"></div>

<div id="endOverlay" class="end-overlay">
  <div class="end-backdrop"></div>
  <div class="end-card">
    <div class="end-icon" id="endIcon">üèÜ</div>
    <h2 class="end-title" id="endTitle">Victoire !</h2>
    <p class="end-message" id="endMessage">F√©licitations pour cette victoire !</p>
    <div class="end-stats">
      <div class="stat-item">
        <span class="stat-value x" id="statX">0</span>
        <span class="stat-label">Minis X</span>
      </div>
      <div class="stat-item">
        <span class="stat-value o" id="statO">0</span>
        <span class="stat-label">Minis O</span>
      </div>
    </div>
    <div class="end-actions">
      <button class="end-btn primary" id="endReplay" type="button">üîÑ Rejouer</button>
      <button class="end-btn secondary" id="endClose" type="button">‚úñÔ∏è Fermer</button>
    </div>
  </div>
</div>

<script>
if ('serviceWorker' in navigator && window.location.protocol === 'https:') {
  window.addEventListener('load', () => {
    const swCode = `
      const CACHE_NAME = 'ultimate-morpion-v1';
      const urlsToCache = ['/'];
      self.addEventListener('install', event => {
        event.waitUntil(
          caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache))
        );
      });
      self.addEventListener('fetch', event => {
        event.respondWith(
          caches.match(event.request).then(response => response || fetch(event.request))
        );
      });
    `;
    const blob = new Blob([swCode], { type: 'application/javascript' });
    const swUrl = URL.createObjectURL(blob);
    navigator.serviceWorker.register(swUrl)
      .then(reg => console.log('‚úÖ Service Worker enregistr√©'))
      .catch(err => console.log('‚ö†Ô∏è Service Worker non disponible (HTTPS requis)'));
  });
}

let deferredPrompt;
const installBtn = document.getElementById('installBtn');
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  installBtn.classList.add('show');
});
installBtn.addEventListener('click', async () => {
  if (!deferredPrompt) return;
  deferredPrompt.prompt();
  const { outcome } = await deferredPrompt.userChoice;
  if (outcome === 'accepted') console.log('‚úÖ PWA install√©e');
  deferredPrompt = null;
  installBtn.classList.remove('show');
});

const manifest = {
  name: "Ultimate Morpion",
  short_name: "Morpion",
  description: "Jouez au morpion ultime en ligne ou hors ligne",
  start_url: window.location.pathname,
  display: "standalone",
  background_color: "#0f172a",
  theme_color: "#0f172a",
  orientation: "portrait",
  icons: [{
    src: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect fill='%230f172a' width='512' height='512' rx='100'/><text x='256' y='380' font-size='300' text-anchor='middle' fill='%23fff'>üéÆ</text></svg>",
    sizes: "512x512",
    type: "image/svg+xml",
    purpose: "any maskable"
  }]
};
const manifestBlob = new Blob([JSON.stringify(manifest)], { type: 'application/json' });
const manifestURL = URL.createObjectURL(manifestBlob);
document.getElementById('manifest-link').setAttribute('href', manifestURL);

const LINES = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];

const state = {
  board: Array.from({length:9},()=>Array(9).fill(null)),
  miniStatus: Array(9).fill(null),
  current: 'X',
  forcedMini: null,
  globalWin: null,
  history: [],
  mode: 'local',
  aiLevel: 3,
  net: { ws:null, url:'', room:'', side:null, connected:false },
  timer: null,
  timeLeft: 30,
  chrono: null,
  chronoTime: 0,
  theme: 'light'
};

const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const activeMiniTextEl = document.getElementById('activeMiniText');
const modeSel = document.getElementById('modeSel');
const aiLevelSel = document.getElementById('aiLevelSel');
const aiWrap = document.getElementById('aiWrap');
const netWrap = document.getElementById('netWrap');
const roomWrap = document.getElementById('roomWrap');
const wsUrlInput = document.getElementById('wsUrl');
const roomInput = document.getElementById('room');
const joinBtn = document.getElementById('joinBtn');
const resetBtn = document.getElementById('resetBtn');
const undoBtn = document.getElementById('undoBtn');
const endOverlay = document.getElementById('endOverlay');
const endIcon = document.getElementById('endIcon');
const endTitle = document.getElementById('endTitle');
const endMessage = document.getElementById('endMessage');
const statX = document.getElementById('statX');
const statO = document.getElementById('statO');
const endReplay = document.getElementById('endReplay');
const endClose = document.getElementById('endClose');
const themeToggle = document.getElementById('themeToggle');
const timerDisplay = document.getElementById('timerDisplay');
const chronoDisplay = document.getElementById('chronoDisplay');
const playerIndicator = document.getElementById('playerIndicator');
const playerSide = document.getElementById('playerSide');
const turnText = document.getElementById('turnText');

function loadTheme() {
  const saved = localStorage.getItem('theme') || 'light';
  state.theme = saved;
  document.documentElement.setAttribute('data-theme', saved);
  themeToggle.textContent = saved === 'dark' ? '‚òÄÔ∏è' : 'üåì';
  const metaTheme = document.querySelector('meta[name="theme-color"]');
  if (metaTheme) metaTheme.setAttribute('content', saved === 'dark' ? '#0f172a' : '#ffffff');
}

themeToggle.addEventListener('click', () => {
  state.theme = state.theme === 'light' ? 'dark' : 'light';
  document.documentElement.setAttribute('data-theme', state.theme);
  localStorage.setItem('theme', state.theme);
  themeToggle.textContent = state.theme === 'dark' ? '‚òÄÔ∏è' : 'üåì';
  const metaTheme = document.querySelector('meta[name="theme-color"]');
  if (metaTheme) metaTheme.setAttribute('content', state.theme === 'dark' ? '#0f172a' : '#ffffff');
});

function startTimer() {
  stopTimer();
  state.timeLeft = 30;
  updateTimerDisplay();
  state.timer = setInterval(() => {
    state.timeLeft--;
    updateTimerDisplay();
    if (state.timeLeft <= 0) {
      stopTimer();
      handleTimeout();
    }
  }, 1000);
}

function stopTimer() {
  if (state.timer) {
    clearInterval(state.timer);
    state.timer = null;
  }
}

function updateTimerDisplay() {
  timerDisplay.textContent = state.timeLeft + 's';
  timerDisplay.classList.remove('warning', 'critical');
  if (state.timeLeft <= 5) timerDisplay.classList.add('critical');
  else if (state.timeLeft <= 10) timerDisplay.classList.add('warning');
}

function handleTimeout() {
  state.current = state.current === 'X' ? 'O' : 'X';
  if (state.mode === 'blitz-online' && state.net.connected) {
    sendNet({ t: 'timeout', room: state.net.room });
  }
  render();
  if ((state.mode === 'blitz-local' || state.mode === 'blitz-online') && !state.globalWin) {
    startTimer();
  }
}

function startChrono() {
  stopChrono();
  state.chronoTime = 0;
  updateChronoDisplay();
  state.chrono = setInterval(() => {
    state.chronoTime++;
    updateChronoDisplay();
  }, 1000);
}

function stopChrono() {
  if (state.chrono) {
    clearInterval(state.chrono);
    state.chrono = null;
  }
}

function updateChronoDisplay() {
  const minutes = Math.floor(state.chronoTime / 60);
  const seconds = state.chronoTime % 60;
  chronoDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

function updatePlayerIndicator() {
  if (state.mode === 'online' || state.mode === 'blitz-online') {
    if (state.net.side === 'X' || state.net.side === 'O') {
      playerIndicator.classList.remove('hide');
      playerSide.textContent = state.net.side;
      playerSide.className = `side-badge ${state.net.side.toLowerCase()}`;
      if (state.current === state.net.side && !state.globalWin) {
        turnText.textContent = 'üéØ √Ä vous de jouer !';
        turnText.className = 'turn-text your-turn';
      } else if (state.globalWin) {
        turnText.textContent = 'Partie termin√©e';
        turnText.className = 'turn-text waiting';
      } else {
        turnText.textContent = '‚è≥ En attente...';
        turnText.className = 'turn-text waiting';
      }
    } else {
      playerIndicator.classList.add('hide');
    }
  } else {
    playerIndicator.classList.add('hide');
  }
}

function cellMark(player){
  if (player==='X'){
    return `<span class="mark x"><svg viewBox="0 0 24 24"><path d="M5 5L19 19"></path><path d="M19 5L5 19"></path></svg></span>`;
  } else {
    return `<span class="mark o"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="8"></circle></svg></span>`;
  }
}

function bigOverlaySVG(player){
  if (player==='X'){
    return {
      colorClass:'winX',
      shape:`<svg viewBox="0 0 24 24"><path d="M5 5L19 19"></path><path d="M19 5L5 19"></path></svg>`
    };
  } else {
    return {
      colorClass:'winO',
      shape:`<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="8"></circle></svg>`
    };
  }
}

function fullRender(){
  boardEl.innerHTML = '';
  for (let m=0; m<9; m++){
    const miniEl = document.createElement('div');
    miniEl.className = 'mini';
    miniEl.dataset.mini = m;
    for (let c=0; c<9; c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.m = m;
      cell.dataset.c = c;
      cell.addEventListener('click', onCellClick);
      cell.addEventListener('mouseenter', onCellEnter);
      cell.addEventListener('mouseleave', onCellLeave);
      miniEl.appendChild(cell);
    }
    boardEl.appendChild(miniEl);
  }
  render();
}

function render(){
  for (let m=0; m<9; m++){
    const miniEl = boardEl.children[m];
    const miniWon = state.miniStatus[m];
    const isActive = isMiniPlayable(m);
    miniEl.classList.toggle('active', isActive && !state.globalWin);
    for (let c=0; c<9; c++){
      const cell = miniEl.children[c];
      const canPlay = !state.globalWin && isActive && !state.board[m][c];
      cell.classList.toggle('disabled', !canPlay);
      cell.innerHTML = '';
      if (state.board[m][c]) cell.innerHTML = cellMark(state.board[m][c]);
    }
    miniEl.classList.remove('winX','winO','won');
    const prevOverlay = miniEl.querySelector('.winnerOverlay');
    if (prevOverlay) prevOverlay.remove();
    if (miniWon==='X' || miniWon==='O'){
      const { colorClass, shape } = bigOverlaySVG(miniWon);
      miniEl.classList.add(colorClass);
      miniEl.classList.add('won');
      const ov = document.createElement('div');
      ov.className = 'winnerOverlay';
      ov.innerHTML = shape;
      miniEl.appendChild(ov);
    }
  }
  for (let m=0;m<9;m++){
    const miniEl = boardEl.children[m];
    miniEl.classList.toggle('globalWin', state.globalWin==='X' || state.globalWin==='O');
  }
  const cur = state.current;
  const dot = `<span class="dot ${cur.toLowerCase()}"></span>`;
  if (!state.globalWin){
    statusEl.innerHTML = `<span class="badge">${dot}Tour : ${cur}</span>`;
  } else if (state.globalWin==='D'){
    statusEl.innerHTML = `<span class="badge">Match nul</span>`;
  } else {
    const winner = state.globalWin;
    const wdot = `<span class="dot ${winner.toLowerCase()}"></span>`;
    statusEl.innerHTML = `<span class="badge">${wdot}${winner} a gagn√© !</span>`;
  }
  if (state.forcedMini===null){
    activeMiniTextEl.textContent = 'Mini impos√© : libre';
  } else {
    activeMiniTextEl.textContent = `Mini impos√© : ${state.forcedMini+1}`;
  }
  updatePlayerIndicator();
}

function isMiniPlayable(m){
  if (state.forcedMini!==null) return state.forcedMini===m;
  return !state.miniStatus[m];
}

function onCellEnter(e){
  const cell = e.currentTarget;
  const m = +cell.dataset.m;
  const c = +cell.dataset.c;
  if (state.board[m][c] !== null) return;
  if (!isMiniPlayable(m)) return;
  if (state.globalWin) return;
  if (!isLocalTurnForThisClient()) return;
  const cls = state.current === 'X' ? 'x' : 'o';
  const shape = state.current === 'X'
    ? `<svg viewBox="0 0 24 24"><path d="M5 5L19 19"></path><path d="M19 5L5 19"></path></svg>`
    : `<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="8"></circle></svg>`;
  const ghost = document.createElement('div');
  ghost.className = `ghost ${cls}`;
  ghost.innerHTML = shape;
  cell.appendChild(ghost);
}

function onCellLeave(e){
  const cell = e.currentTarget;
  const ghost = cell.querySelector('.ghost');
  if (ghost) ghost.remove();
}

function checkLine3(arr, player){
  return LINES.some(([a,b,c])=>arr[a]===player && arr[b]===player && arr[c]===player);
}

function miniWinner(m){
  const grid = state.board[m];
  if (checkLine3(grid,'X')) return 'X';
  if (checkLine3(grid,'O')) return 'O';
  if (grid.every(v=>v!==null)) return 'D';
  return null;
}

function isMiniFull(m){ 
  return state.board[m].every(v=>v!==null); 
}

function updateMiniAndGlobal(m){
  const win = miniWinner(m);
  if (win && !state.miniStatus[m]) state.miniStatus[m] = win;
  const macro = Array(9).fill(null).map((_,i)=>{
    return state.miniStatus[i]==='X' ? 'X' : state.miniStatus[i]==='O' ? 'O' : null;
  });
  if (checkLine3(macro,'X')) state.globalWin = 'X';
  else if (checkLine3(macro,'O')) state.globalWin = 'O';
  else if (state.miniStatus.every(s=>s)) state.globalWin = 'D';
  if (state.globalWin) {
    stopTimer();
    stopChrono();
    setTimeout(() => showEndAnimation(), 500);
  }
}

function applyMove(m,c,fromPlayer=null){
  const player = fromPlayer || state.current;
  if (state.globalWin) return false;
  if (state.board[m][c]!==null) return false;
  if (!isMiniPlayable(m)) return false;
  state.board[m][c] = player;
  state.history.push({ 
    m, c, player, 
    prevForced: state.forcedMini, 
    prevMiniStatus: state.miniStatus.slice(), 
    prevGlobal: state.globalWin 
  });
  updateMiniAndGlobal(m);
  const targetMini = c;
  if (state.miniStatus[targetMini] || isMiniFull(targetMini)){
    state.forcedMini = null;
  } else {
    state.forcedMini = targetMini;
  }
  state.current = state.current==='X' ? 'O' : 'X';
  if ((state.mode === 'blitz-local' || state.mode === 'blitz-online') && !state.globalWin) {
    startTimer();
  }
  return true;
}

function resetGame(){
  stopTimer();
  stopChrono();
  state.board = Array.from({length:9},()=>Array(9).fill(null));
  state.miniStatus = Array(9).fill(null);
  state.current = 'X';
  state.forcedMini = null;
  state.globalWin = null;
  state.history = [];
  fullRender();
  if (state.mode === 'blitz-local' || state.mode === 'blitz-online') {
    startTimer();
  } else if (state.mode === 'local' || state.mode === 'online') {
    startChrono();
  }
}

function undo(){
  if (state.mode==='online') return;
  if (state.mode==='blitz-local') return;
  if (state.mode==='blitz-online') return;
  if (state.history.length===0) return;
  const last = state.history.pop();
  state.board[last.m][last.c] = null;
  state.forcedMini = last.prevForced;
  state.miniStatus = last.prevMiniStatus;
  state.globalWin = last.prevGlobal;
  state.current = last.player;
  render();
}

function cloneState(){
  return {
    board: state.board.map(mini=>mini.slice()),
    miniStatus: state.miniStatus.slice(),
    current: state.current,
    forcedMini: state.forcedMini,
    globalWin: state.globalWin
  };
}

function restoreState(snap){
  state.board = snap.board;
  state.miniStatus = snap.miniStatus;
  state.current = snap.current;
  state.forcedMini = snap.forcedMini;
  state.globalWin = snap.globalWin;
}

function getPossibleMoves(){
  if (state.globalWin) return [];
  const moves = [];
  if (state.forcedMini!==null){
    const m = state.forcedMini;
    if (!state.miniStatus[m]){
      for (let c=0;c<9;c++){
        if (!state.board[m][c]) moves.push({m,c});
      }
    }
  } else {
    for (let m=0;m<9;m++){
      if (state.miniStatus[m]) continue;
      for (let c=0;c<9;c++){
        if (!state.board[m][c]) moves.push({m,c});
      }
    }
  }
  return moves;
}

function evaluate(){
  let score = 0;
  for (let m=0;m<9;m++){
    if (state.miniStatus[m]==='X') score+=3;
    else if (state.miniStatus[m]==='O') score-=3;
    else {
      for (const [a,b,c] of LINES){
        const line=[state.board[m][a],state.board[m][b],state.board[m][c]];
        const xCnt=line.filter(v=>v==='X').length;
        const oCnt=line.filter(v=>v==='O').length;
        if (xCnt>0 && oCnt===0) score+=1;
        if (oCnt>0 && xCnt===0) score-=1;
      }
    }
  }
  const macro = Array(9).fill(null).map((_,i)=>{
    return state.miniStatus[i]==='X' ? 'X' : state.miniStatus[i]==='O' ? 'O' : null;
  });
  for (const [a,b,c] of LINES){
    const line=[macro[a],macro[b],macro[c]];
    const xCnt=line.filter(v=>v==='X').length;
    const oCnt=line.filter(v=>v==='O').length;
    if (xCnt>0 && oCnt===0) score+=6;
    if (oCnt>0 && xCnt===0) score-=6;
  }
  if (state.globalWin==='X') score+=999;
  else if (state.globalWin==='O') score-=999;
  return score;
}

function aiMove(){
  const depth = state.aiLevel;
  const moves = getPossibleMoves();
  if (moves.length===0) return null;
  let bestMove = null;
  let bestVal = -Infinity;
  for (const mv of moves){
    const snapshot = cloneState();
    applyMove(mv.m, mv.c, state.current);
    const val = minimax(depth-1, -Infinity, Infinity);
    restoreState(snapshot);
    if (val > bestVal){
      bestVal = val;
      bestMove = mv;
    }
  }
  return bestMove;
}

function minimax(depth, alpha, beta){
  if (depth===0 || state.globalWin) return evaluate();
  const moves = getPossibleMoves();
  if (moves.length===0) return evaluate();
  const me = state.current;
  if (me==='X'){
    let value = -Infinity;
    for (const mv of moves){
      const snapshot = cloneState();
      applyMove(mv.m, mv.c, me);
      value = Math.max(value, minimax(depth-1, alpha, beta));
      restoreState(snapshot);
      alpha = Math.max(alpha, value);
      if (beta<=alpha) break;
    }
    return value;
  } else {
    let value = Infinity;
    for (const mv of moves){
      const snapshot = cloneState();
      applyMove(mv.m, mv.c, me);
      value = Math.min(value, minimax(depth-1, alpha, beta));
      restoreState(snapshot);
      beta = Math.min(beta, value);
      if (beta<=alpha) break;
    }
    return value;
  }
}

function onCellClick(e){
  const m = +e.currentTarget.dataset.m;
  const c = +e.currentTarget.dataset.c;
  if (!isLocalTurnForThisClient()) return;
  const ghost = e.currentTarget.querySelector('.ghost');
  if (ghost) ghost.remove();
  if (!applyMove(m,c)) return;
  if ((state.mode==='online' || state.mode==='blitz-online') && state.net.connected){
    sendNet({ t:'move', room: state.net.room, data:{ m, c } });
  }
  render();
  maybeAIMove();
}

function maybeAIMove(){
  if (state.mode!=='ai') return;
  if (state.globalWin) return;
  if (state.current === 'X') return;
  setTimeout(()=>{
    const mv = aiMove();
    if (mv){
      applyMove(mv.m, mv.c);
      render();
    }
  }, 150);
}

function isLocalTurnForThisClient(){
  if (state.globalWin) return false;
  if (state.mode==='online' || state.mode==='blitz-online'){
    if (state.net.side==='X' || state.net.side==='O'){
      return state.current===state.net.side;
    }
    return true;
  }
  return true;
}

function connectWS(url){
  try{ 
    if (state.net.ws) state.net.ws.close(); 
  }catch(e){}
  const ws = new WebSocket(url);
  state.net.ws = ws;
  ws.onopen = ()=>{
    state.net.connected = true;
    state.net.url = url;
    sendNet({ t:'join', room: state.net.room });
    updateUI();
    if (state.mode === 'blitz-online') {
      startTimer();
    } else if (state.mode === 'online') {
      startChrono();
    }
  };
  ws.onmessage = (evt)=>{
    try{
      const msg = JSON.parse(evt.data);
      handleNetMsg(msg);
    }catch(e){}
  };
  ws.onerror = (err)=>{ 
    state.net.connected=false; 
    updateUI(); 
  };
  ws.onclose = ()=>{ 
    state.net.connected=false; 
    state.net.side=null;
    stopTimer();
    stopChrono();
    updateUI(); 
  };
}

function sendNet(obj){
  if (!state.net.ws || state.net.ws.readyState!==WebSocket.OPEN) return;
  state.net.ws.send(JSON.stringify(obj));
}

function handleNetMsg(msg){
  if (msg.t==='joined'){
    state.net.side = msg.side;
    updateUI();
    updatePlayerIndicator();
  } else if (msg.t==='state'){
    state.board = msg.data.board;
    state.miniStatus = msg.data.miniStatus;
    state.current = msg.data.current;
    state.forcedMini = msg.data.forcedMini;
    state.globalWin = msg.data.globalWin;
    state.history = [];
    render();
  } else if (msg.t==='move'){
    const {m,c} = msg.data;
    applyMove(m,c);
    render();
  } else if (msg.t==='reset'){
    resetGame();
  } else if (msg.t==='timeout'){
    handleTimeout();
  }
}

function updateUI(){
  aiWrap.classList.toggle('hide', state.mode!=='ai');
  netWrap.classList.toggle('hide', state.mode!=='online' && state.mode!=='blitz-online');
  roomWrap.classList.toggle('hide', state.mode!=='online' && state.mode!=='blitz-online');
  undoBtn.disabled = state.mode==='online' || state.mode==='blitz-local' || state.mode==='blitz-online';
  timerDisplay.classList.toggle('hide', state.mode!=='blitz-local' && state.mode!=='blitz-online');
  chronoDisplay.classList.toggle('hide', state.mode!=='local' && state.mode!=='online');
  updatePlayerIndicator();
  if (state.mode === 'online' || state.mode === 'blitz-online') {
    if (state.net.connected) {
      joinBtn.innerHTML = '‚úÖ Connect√©';
      joinBtn.disabled = true;
    } else {
      joinBtn.innerHTML = 'üîó Rejoindre';
      joinBtn.disabled = false;
    }
  }
  render();
}

resetBtn.addEventListener('click', ()=>{
  hideEndAnimation();
  resetGame();
  if ((state.mode==='online' || state.mode==='blitz-online') && state.net.connected){
    sendNet({ t:'reset', room: state.net.room });
  }
});

undoBtn.addEventListener('click', ()=> undo());

modeSel.addEventListener('change', ()=>{
  const oldMode = state.mode;
  state.mode = modeSel.value;
  if (oldMode === 'blitz-local' || oldMode === 'blitz-online') stopTimer();
  if (oldMode === 'local' || oldMode === 'online') stopChrono();
  if ((oldMode === 'online' || oldMode === 'blitz-online') && state.net.connected) {
    state.net.ws.close();
    state.net.connected = false;
    state.net.side = null;
  }
  updateUI();
  resetGame();
});

aiLevelSel.addEventListener('change', ()=>{ 
  state.aiLevel = +aiLevelSel.value; 
});

joinBtn.addEventListener('click', (e)=>{
  e.preventDefault();
  const url = wsUrlInput.value.trim();
  const room = roomInput.value.trim();
  if (!url || !room) {
    alert('‚ö†Ô∏è Veuillez remplir le serveur et la salle');
    return;
  }
  state.net.room = room;
  connectWS(url);
});

window.addEventListener('keydown', (e)=>{
  if (e.key==='r' || e.key==='R') resetBtn.click();
  if (e.key==='u' || e.key==='U') undo();
  if (e.key === 'Escape' && endOverlay.classList.contains('show')) {
    hideEndAnimation();
  }
});

function showEndAnimation() {
  if (!state.globalWin) return;
  let x = 0, o = 0;
  for (const s of state.miniStatus) {
    if (s === 'X') x++;
    if (s === 'O') o++;
  }
  statX.textContent = x;
  statO.textContent = o;
  endOverlay.classList.remove('victory', 'defeat', 'draw');
  if (state.globalWin === 'X') {
    endOverlay.classList.add('victory');
    endIcon.textContent = 'üèÜ';
    endTitle.textContent = 'Victoire !';
    endMessage.textContent = getVictoryMessage();
    createConfetti();
  } else if (state.globalWin === 'O') {
    endOverlay.classList.add('defeat');
    endIcon.textContent = 'üòî';
    endTitle.textContent = 'D√©faite';
    endMessage.textContent = getDefeatMessage();
  } else {
    endOverlay.classList.add('draw');
    endIcon.textContent = 'ü§ù';
    endTitle.textContent = 'Match nul';
    endMessage.textContent = 'Partie serr√©e ! R√©essayez pour la victoire.';
  }
  setTimeout(() => {
    endOverlay.classList.add('show');
  }, 100);
}

function getVictoryMessage() {
  if (state.mode === 'ai') {
    const level = state.aiLevel;
    if (level <= 2) return 'Vous avez battu l\'IA facilement !';
    if (level === 3) return 'Belle victoire contre l\'IA !';
    if (level === 4) return 'Impressionnant ! L\'IA √©tait coriace !';
    return 'Incroyable ! Vous avez vaincu l\'IA niveau 5 !';
  } else if (state.mode === 'online' || state.mode === 'blitz-local' || state.mode === 'blitz-online') {
    return 'Vous avez gagn√© la partie !';
  }
  return 'F√©licitations pour cette victoire !';
}

function getDefeatMessage() {
  if (state.mode === 'ai') {
    return 'L\'IA √©tait trop forte cette fois !';
  } else if (state.mode === 'online' || state.mode === 'blitz-local' || state.mode === 'blitz-online') {
    return 'Votre adversaire a gagn√© cette fois !';
  }
  return 'Dommage ! R√©essayez !';
}

function createConfetti() {
  const colors = ['#10b981', '#3b82f6', '#f59e0b', '#ef4444', '#8b5cf6'];
  for (let i = 0; i < 50; i++) {
    setTimeout(() => {
      const confetti = document.createElement('div');
      confetti.className = 'confetti';
      confetti.style.left = Math.random() * 100 + '%';
      confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
      confetti.style.animationDelay = Math.random() * 0.3 + 's';
      confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
      endOverlay.appendChild(confetti);
      setTimeout(() => confetti.remove(), 3500);
    }, i * 30);
  }
}

function hideEndAnimation() {
  endOverlay.classList.remove('show');
  setTimeout(() => {
    endOverlay.classList.remove('victory', 'defeat', 'draw');
    endOverlay.querySelectorAll('.confetti').forEach(c => c.remove());
  }, 400);
}

endReplay.addEventListener('click', () => {
  hideEndAnimation();
  resetGame();
  if ((state.mode==='online' || state.mode==='blitz-online') && state.net.connected){
    sendNet({ t:'reset', room: state.net.room });
  }
});

endClose.addEventListener('click', () => {
  hideEndAnimation();
});

(function init(){
  loadTheme();
  fullRender();
  modeSel.value = state.mode;
  aiLevelSel.value = String(state.aiLevel);
  updateUI();
  if (state.mode === 'local') {
    startChrono();
  }
})();
</script>

</body>
</html>
